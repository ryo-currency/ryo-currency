// Copyright (c) 2017-2018, The Monero Project
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without modification, are
// permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this list of
//    conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice, this list
//    of conditions and the following disclaimer in the documentation and/or other
//    materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its contributors may be
//    used to endorse or promote products derived from this software without specific
//    prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include <cstdint>
#include <gtest/gtest.h>
#include <memory>
#include <string>

#include "crypto/crypto.h"

namespace
{

static constexpr const char *out_key[] = {
	"\xa\xa5\xe6\x72\x2d\x54\x24\x23\x2d\xc8\xb6\xb9\x5\xf7\x21\xc0\xa4\x3f\x29\x16\x8\x79\x9a\xd4\xbc\x5e\xb0\xa7\x58\x1c\xcb\xbf",
	"\x1f\xaf\x5c\x17\x41\xad\x85\xa4\x73\x15\x75\x43\x23\x6c\xcd\x66\xaf\xe0\x8b\xc5\xa\xb0\xb9\xfc\x2a\xc0\x1f\x80\x3a\x47\x9d\x68",
	"\x5c\x97\xc0\x40\xab\xb6\x7e\xa5\x27\x24\x54\x72\xb7\x7c\xe1\x3e\xec\x8\x29\x58\x5\x1\x6d\x2d\xa8\xf0\x80\xbf\x49\x5a\x27\x6b",
	"\x17\x8e\x3a\xe8\xf4\x44\xe9\x3a\x7a\xf3\xaf\xa5\x50\xa7\xba\x3\xe9\x9e\x4c\x6\x6c\x3\x0\xc5\x23\x46\x62\x17\x37\x62\x17\x73",
	"\xe3\x5c\xa6\x3b\x87\xa3\xf7\xd0\x1b\x41\xe9\xb9\x76\x3c\xc1\xf6\x6a\x1a\x90\x62\xa2\xb4\xbd\xe8\x46\xf9\x4e\x26\xc7\xa4\x54\x79",
	"\xff\xbf\xc0\x85\x80\xe2\x8c\x32\x29\x55\xca\x16\x78\x56\xe3\x25\x92\x88\xa2\x1e\x33\x9\xd6\xae\x15\x1\xdf\xa8\xa4\x88\x1\x28",
	"\xb8\x8b\xf9\x91\x98\x20\x34\xdf\xb\xf0\x96\xaf\x69\x74\x51\xd\xad\x5a\xa\x54\x23\x97\x64\x29\xec\x28\x47\xba\xbf\x47\x59\x50",
	"\xff\x4b\x9c\x89\x3e\x55\xa8\xf8\x41\x7c\x49\xe2\x59\x9c\xdd\xa2\x37\x98\x11\x11\x9a\xba\x87\xfc\x29\x57\xc3\x4a\xa5\xd1\x5d\xdc"};

static constexpr const char *derivation[] = {
	"\xaa\x52\xa2\x3e\x49\x41\xb7\x9a\xaf\x88\x9d\x63\x29\xaa\xef\xce\xe5\x82\x5\x91\xa5\x65\xa8\x23\x91\x1c\x44\xa0\x7b\x3c\xed\xed",
	"\x6e\xec\x86\xe7\x9d\x68\xad\x8a\xc6\x8d\x48\xb1\xcd\x12\xd6\x2\x6f\xbe\x71\x4e\x10\x7a\x7\xb3\xf\x97\xe3\xc0\xb\x61\x1b\xda",
	"\xd7\xe2\xdf\x49\x84\xd9\x6b\x56\x6f\x46\x74\xd3\x2\x9\xa6\xf8\xa0\x72\x4d\x9f\xcf\x5b\x17\x63\x2c\x59\xab\xa7\xed\x36\xa5\x3f",
	"\x73\x36\xdf\xf1\x6c\xa\x66\x3f\xed\x68\xf\xa3\xbf\xfa\x73\xe8\x2d\x55\xb3\x38\xe3\x6d\x55\x5c\x66\x76\xbb\x69\x51\xe3\xca\x6d",
	"\x78\x44\x6\x65\x34\x53\x7\x7c\x6a\xcc\xd4\xc9\x92\xf3\x2b\xda\x60\x13\x61\x9a\x92\xad\xf6\xd4\xda\x21\x6b\xbb\x77\x10\xe8\x9c",
	"\xfa\x25\x66\xc8\x29\xe5\x21\x5b\x18\x1a\xc0\x82\xc4\x85\xfa\x8\xcd\x31\xb7\x65\x54\xf\x6b\x42\x69\xbc\xff\x23\xc1\xf9\xed\xf1",
	"\x8\xfb\x94\xc0\xc8\xec\x21\x82\xa9\x80\x5e\x8e\x1f\x80\xbc\x31\x9a\x39\x2c\x62\x2c\x6f\x59\xe4\x78\x15\xf5\x10\x67\x2\x67\xfb",
	"\x72\xc1\x7d\x18\x92\xf3\xbd\x77\xa3\x1e\xe5\xb0\xb\x4d\x1e\x97\x27\x38\x6\x4d\x44\x70\x41\x24\xe6\x81\xc\x2d\xf5\xe1\xcf\xe0"};

static constexpr const char *derived_key[] = {
	"\xf5\x11\x12\x9d\x86\x63\x77\x73\x5d\x62\x21\xf9\x56\x75\xba\xcf\x9c\x64\xf\x54\xfa\xbe\x30\x15\xf2\x74\x64\x3b\x20\xf9\x27\x48",
	"\x46\x59\x7e\xd6\x5b\x7b\x1c\xe8\x9\xb9\x9\x66\x6e\x92\x64\x88\x2e\xe4\x51\xde\x29\xdf\x15\xa7\xc\xdf\xf6\xb4\x20\x4f\x28\xe3",
	"\xb\x22\x87\x9b\x51\xc8\xa0\xe1\x8\x6f\x24\xb7\xef\x26\xcf\xc8\x9e\xfd\x49\x44\x94\xe8\xb9\x4d\x60\xa1\xf4\x25\xaa\x2c\x4b\xb",
	"\x6c\xf6\xcf\xbe\x35\xe0\xb1\x3e\x35\x65\x25\x91\x8e\xfc\xcf\xc5\x4e\x51\x56\x83\x2d\xf0\xdf\x33\x62\x77\xe2\x36\x67\x56\x7e\x9c",
	"\x85\x7f\x38\x54\x73\xb4\x17\xc4\x91\x33\x72\x2d\x81\x2b\x8a\x3a\x61\x7a\xaf\xeb\x82\x50\xc1\x1a\x3c\x87\x8d\x43\xce\x65\x2a\x36",
	"\x73\xf0\xbc\xec\x55\x41\xae\x8e\xa0\xd7\x3f\xb2\xa9\xf0\x24\x26\xaa\xe7\xf0\x92\x9e\xc2\x64\x36\x42\x52\x6e\x3\x11\x25\x5b\x33",
	"\x42\x1\x5\xed\x26\xf2\xdf\xbb\xaf\xda\x73\xba\xf9\xcc\x9b\xee\x17\x94\x44\xb9\x56\xba\x57\x6a\x6a\xcf\x60\x35\xa5\xe3\xe5\xbe",
	"\x47\x52\x71\xcb\x1e\xc0\xc7\x52\x10\x9c\xd9\x71\xd8\x59\xd9\x51\x4b\xe6\x73\x45\xc8\x7b\xfc\xc7\x62\x26\xd1\xd\x2a\xc\xe8\x87"};

} // namespace

TEST(Crypto, derive_subaddress_public_key)
{
	using namespace crypto;
	for(int i = 0; i < 8; ++i)
	{
		public_key pk;
		memcpy(pk.data, out_key[i], 32u);

		key_derivation dk;
		memcpy(dk.data, derivation[i], 32u);

		public_key result_key;
		derive_subaddress_public_key(pk, dk, 0, result_key);

		ASSERT_EQ(memcmp(derived_key[i], result_key.data, 32), 0);
	}
}

#ifdef HAVE_EC_64
// test for the optimized x86 64bit elliptic curve implementation
TEST(Crypto, derive_subaddress_public_key_64)
{
	using namespace crypto;
	for(int i = 0; i < 8; ++i)
	{
		public_key pk;
		memcpy(pk.data, out_key[i], 32u);

		key_derivation dk;
		memcpy(dk.data, derivation[i], 32u);

		public_key result_key;
		derive_subaddress_public_key_64(pk, dk, 0, result_key);

		ASSERT_EQ(memcmp(derived_key[i], result_key.data, 32), 0);
	}
}
#endif

namespace
{

static constexpr const char *pub_key[] = {
	"\x41\x4c\x48\xee\x10\x44\x4f\x81\x4b\x4b\xc7\x4f\xdd\x1d\xfb\x1a\xd0\x0\x1\x55\x10\x74\xfc\x1c\xad\x25\xea\xec\xa0\x67\x76\x5",
	"\x22\x9c\x8d\xb4\x25\xcb\x3\x13\xf1\x8a\x77\x4\x52\xc9\x2d\xc6\xfe\x6f\xaf\x9a\xdf\xad\xee\x22\x43\x44\xa1\x80\xe4\xf\x55\x37",
	"\x3d\x36\xe1\x80\x62\xc8\x9a\x36\x44\xc\x8\x70\xa6\x5c\xe9\x94\x72\xf8\xa8\x5b\x93\xba\x32\x65\x45\xf6\xb6\x38\x47\x34\xdf\x17",
	"\x85\x23\x56\x69\x7c\x48\xf0\x7e\xfe\xb\xf3\xff\xac\x31\x8c\xf2\x60\x15\x10\x5f\x8c\xdb\x4f\x23\xa\x1d\x6e\x47\xc1\x41\x5d\x4d",
	"\x38\x1d\x13\x2d\x61\x91\xd3\xfd\xbc\xff\xe0\x25\x78\x49\x65\x3d\xa8\x4e\x37\x7d\x85\x87\xa8\x72\x39\x8f\xda\xd\xd8\x2d\xb3\x10"

};

static constexpr const char *sec_key[] = {
	"\x78\x82\xd1\x40\xdd\xd2\xc9\x92\xaa\x11\x14\xf3\x3d\xca\x91\xab\xf5\x9f\x96\xa6\x7d\xf0\x4c\xc0\x3b\xe9\x30\x8\x1c\x56\xf0\x1",
	"\x78\x82\xd1\x40\xdd\xd2\xc9\x92\xaa\x11\x14\xf3\x3d\xca\x91\xab\xf5\x9f\x96\xa6\x7d\xf0\x4c\xc0\x3b\xe9\x30\x8\x1c\x56\xf0\x1",
	"\x78\x82\xd1\x40\xdd\xd2\xc9\x92\xaa\x11\x14\xf3\x3d\xca\x91\xab\xf5\x9f\x96\xa6\x7d\xf0\x4c\xc0\x3b\xe9\x30\x8\x1c\x56\xf0\x1",
	"\xd2\x49\x6f\x35\x88\x9b\x64\x51\xdf\x53\x73\x37\x37\x1b\xe2\x9\x6a\xf9\x6\x62\x6c\xe8\xb7\xfa\x3c\xa4\xf6\xdd\xad\x59\x54\x3",
	"\xd2\x49\x6f\x35\x88\x9b\x64\x51\xdf\x53\x73\x37\x37\x1b\xe2\x9\x6a\xf9\x6\x62\x6c\xe8\xb7\xfa\x3c\xa4\xf6\xdd\xad\x59\x54\x3"

};

static constexpr const char *res_derived_key[] = {
	"\x8e\x50\x71\xb8\x28\xe2\xd5\xdb\x1f\x8d\xad\xc6\x26\x2d\xc9\x9f\x0\xa1\x74\x73\xec\x5e\xac\x5f\x21\x4c\x55\xfe\x82\x21\xba\x26",
	"\xd1\x89\xd5\xa2\x1e\x80\x19\xee\x39\x54\xc7\xc1\x7c\x5c\xfe\x2a\x48\xf6\x4d\x27\xf7\xef\x48\x43\xd1\xf3\x6e\x47\x72\xe4\xcd\x7c",
	"\x5d\x20\x68\xd7\x76\x5f\xf0\x90\x2\xa6\x65\xae\xf\xc\x7b\xe4\xef\xa8\x9\x52\x2d\xfd\x41\x8d\xb7\x6d\x73\x18\xb7\xb7\xba\x5f",
	"\x1a\x9a\x57\x21\x4f\xdd\xf5\x1e\x58\x8e\x63\x81\x83\x7e\xf3\xb6\xe4\x85\xa8\xee\xb7\x81\x45\x8d\xa0\xa8\x6\xd0\xbe\xca\x8d\x8c",
	"\xb4\x90\x74\xe9\x76\x5d\xf3\xc4\xd9\x8c\x9d\xea\x47\x51\x52\x59\x66\xeb\xb5\x7f\x1b\x4a\xbd\x5a\x2c\x7a\xb6\xea\x5f\x3e\x33\x52"};

} // namespace

TEST(Crypto, generate_key_derivation)
{
	using namespace crypto;
	for(int i = 0; i < 5; ++i)
	{
		public_key pk;
		memcpy(pk.data, pub_key[i], 32u);

		secret_key sk;
		memcpy(sk.data, sec_key[i], 32u);

		key_derivation result_key;
		generate_key_derivation(pk, sk, result_key);

		ASSERT_EQ(memcmp(res_derived_key[i], result_key.data, 32), 0);
	}
}

#ifdef HAVE_EC_64
// test for the optimized x86 64bit elliptic curve implementation
TEST(Crypto, generate_key_derivation_64)
{
	using namespace crypto;
	for(int i = 0; i < 5; ++i)
	{
		public_key pk;
		memcpy(pk.data, pub_key[i], 32u);

		secret_key sk;
		memcpy(sk.data, sec_key[i], 32u);

		key_derivation result_key;
		generate_key_derivation_64(pk, sk, result_key);

		ASSERT_EQ(memcmp(res_derived_key[i], result_key.data, 32), 0);
	}
}
#endif
