// Copyright (c) 2014-2018, The Monero Project
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without modification, are
// permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this list of
//    conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice, this list
//    of conditions and the following disclaimer in the documentation and/or other
//    materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its contributors may be
//    used to endorse or promote products derived from this software without specific
//    prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Parts of this file are originally copyright (c) 2012-2013 The Cryptonote developers

#include <cstddef>
#include <fstream>
#include <iomanip>
#include <ios>
#include <string>

#include "../io.h"
#include "crypto/hash.h"
#include "crypto/pow_hash/aux_hash.h"
#include "crypto/pow_hash/cn_slow_hash.hpp"
#include "warnings.h"

using namespace std;
using namespace crypto;
typedef crypto::hash chash;

PUSH_WARNINGS
DISABLE_VS_WARNINGS(4297)
extern "C"
{
	static void hash_tree(const void *data, size_t length, char *hash)
	{
		if((length & 31) != 0)
		{
			throw ios_base::failure("Invalid input length for tree_hash");
		}
		tree_hash((const char(*)[crypto::HASH_SIZE])data, length >> 5, hash);
	}
	static void cn_pow_hash_original(const void *data, size_t length, char *hash)
	{
		cn_pow_hash_v2 ctx;
		cn_pow_hash_v1 ctx_v1 = cn_pow_hash_v1::make_borrowed(ctx);
		ctx_v1.hash(data, length, hash);
	}
	static void cn_pow_hash_heavy(const void *data, size_t length, char *hash)
	{
		cn_pow_hash_v2 ctx;
		ctx.hash(data, length, hash);
	}
	static void hash_extra_blake(const void *data, size_t length, char *hash)
	{
		if(length != 200)
		{
			throw ios_base::failure("Invalid input length for hash_extra_blake");
		}
		blake256_hash((uint8_t *)data, (uint8_t *)hash);
	}
	static void hash_extra_groestl(const void *data, size_t length, char *hash)
	{
		if(length != 200)
		{
			throw ios_base::failure("Invalid input length for hash_extra_groestl");
		}
		groestl_hash((uint8_t *)data, (uint8_t *)hash);
	}
	static void hash_extra_jh(const void *data, size_t length, char *hash)
	{
		if(length != 200)
		{
			throw ios_base::failure("Invalid input length for hash_extra_jh");
		}
		jh_hash((uint8_t *)data, (uint8_t *)hash);
	}
	static void hash_extra_skein(const void *data, size_t length, char *hash)
	{
		if(length != 200)
		{
			throw ios_base::failure("Invalid input length for hash_extra_skein");
		}
		skein_hash((uint8_t *)data, (uint8_t *)hash);
	}
} // extern "C"
POP_WARNINGS

extern "C" typedef void hash_f(const void *, size_t, char *);
struct hash_func
{
	const string name;
	hash_f &f;
} hashes[] = {
	{"fast", cn_fast_hash},
	{"pow-original", cn_pow_hash_original},
	{"tree", hash_tree},
	{"extra-blake", hash_extra_blake},
	{"extra-groestl", hash_extra_groestl},
	{"extra-jh", hash_extra_jh},
	{"extra-skein", hash_extra_skein},
	{"pow-heavy", cn_pow_hash_heavy}};

int main(int argc, char *argv[])
{
	hash_f *f;
	hash_func *hf;
	fstream input;
	vector<char> data;
	chash expected, actual;
	size_t test = 0;
	bool error = false;
	if(argc != 3)
	{
		cerr << "Wrong number of arguments" << endl;
		return 1;
	}
	for(hf = hashes;; hf++)
	{
		if(hf >= &hashes[sizeof(hashes) / sizeof(hash_func)])
		{
			cerr << "Unknown function" << endl;
			return 1;
		}
		if(argv[1] == hf->name)
		{
			f = &hf->f;
			break;
		}
	}
	input.open(argv[2], ios_base::in);
	for(;;)
	{
		++test;
		input.exceptions(ios_base::badbit);
		get(input, expected);
		if(input.rdstate() & ios_base::eofbit)
		{
			break;
		}
		input.exceptions(ios_base::badbit | ios_base::failbit | ios_base::eofbit);
		input.clear(input.rdstate());
		get(input, data);
		f(data.data(), data.size(), (char *)&actual);
		if(expected != actual)
		{
			size_t i;
			cerr << "Hash mismatch on test " << test << endl
				 << "Input: ";
			if(data.size() == 0)
			{
				cerr << "empty";
			}
			else
			{
				for(i = 0; i < data.size(); i++)
				{
					cerr << setbase(16) << setw(2) << setfill('0') << int(static_cast<unsigned char>(data[i]));
				}
			}
			cerr << endl
				 << "Expected hash: ";
			for(i = 0; i < 32; i++)
			{
				cerr << setbase(16) << setw(2) << setfill('0') << int(reinterpret_cast<unsigned char *>(&expected)[i]);
			}
			cerr << endl
				 << "Actual hash: ";
			for(i = 0; i < 32; i++)
			{
				cerr << setbase(16) << setw(2) << setfill('0') << int(reinterpret_cast<unsigned char *>(&actual)[i]);
			}
			cerr << endl;
			error = true;
		}
	}
	return error ? 1 : 0;
}
